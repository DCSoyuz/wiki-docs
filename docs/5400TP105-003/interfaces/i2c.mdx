---
id: mk-i2c
title: I2C
sidebar_label: I2C
sidebar_position: 4
---

Интерфейс I2C применяется для связи между собой однокристальных микроконтроллеров, ЖКИ-индикаторов, портов ввода-вывода, микросхем памяти, аналого-цифровых и цифро-аналоговых преобразователей и т.д.

## Основные характеристики:

- только две линии – последовательная линия данных (SDA) и последовательная линия синхронизации (SCL)
- возможностью работы в multi-master среде
- последовательная передача данных по 8 бит
- скорости передачи данных: 100 кбит/с, 400 кбит/с
- фильтрация сигналов на линиях передачи данных (SDA, SCL) от помех
- глубина буфера приемника и передатчика 8 слов

Все операции на шине I2C осуществляются при помощи двух проводов SDA и SCL. Как SDA, так и SCL являются двунаправленными линиями, которые необходимо подсоединить к положительному источнику питания через подтягивающий резистор. Когда шина свободна, обе линии за счет подтягивающих резисторов принимают высокий логический уровень. Выходные каскады устройств, подключенных к шине, должны иметь открытый сток или открытый коллектор.

## Структурная схема

<DocumentFigure src="/img/5400TP105-003/i2c/Стуктурная_схема_I2C.svg" caption="Структурная схема I2C" />

I2C состоит из следующих блоков:

- REGISTERS – блок для хранения управляющих данных и статусов;
- FIFO_TX – буфер передатчика;
- FIFO_RX – буфер приемника;
- SEQUENCER/ARBITER – управляющий автомат интерфейса;
- SERIALIZER/DESERIALIZER – блок предназначен для преобразования параллельного потока данных от управляющего автомата в последовательный, а также для преобразования последовательно потока с внешней шины, в параллельный – для управляющего автомата.

## Алгоритмы работы

### Процедура передачи данных ведущим

- в регистрах I2C_MSK0, I2C_MSK1, I2C_MSK2 разрешить необходимые прерывания;
- в регистре I2C_CFG установить биты FILT_DEPTH, определяющие глубину фильтрации;
- в регистре I2C_PRSC0 определить длительность высокого и низкого уровня SCL, установив младшие 8 бит PRSC;
- в регистре I2C_PRSC1:
  - определить режим работы битом F/S, если выбран Fast-mode, то задать коэффициент заполнения битом DUTY;
  - определить длительность высокого и низкого уровня SCL, установив старшие 4 бита PRSC.
- в регистре I2C_PRSC3 установить максимальную длительность петли обратной связи линии SCL битами TRISE;
- записать адрес c «0» в младшем бите и отправляемые данные в регистр I2C_TXFIFO (данный этап можно провести после включения или подачи START последовательности; также данные можно дописывать как во время передачи, контролируя состояние буфера посредствам регистра I2C_TXWORDS, статуса BTF регистра I2C_ST0 или статуса FIFO_EMPTY_TX регистра I2C_ST1 и соответствующего прерывания, так и после когда бит статуса TX_END_EMPTY_FIFO регистра I2C_ST2 уже выставлен);
- в регистре I2C_CTRL:
  - определить тип адресации битом ADDR_MOD;
  - установить бит START;
  - включить модуль битом EN.
- по статусному биту FIFO\*EMPTY*TX регистра I2C_ST1 или TX_END_EMPTY_FIFO регистра I2C_ST2 установить бит STOP регистра I2C_CTRL (если бит STOP устанавливается по флагу FIFO_EMPTY_TX, т.е. во время передачи последнего слова, то STOP последовательность будет развернута незамедлительно после отправки последнего байта данных и считывания его бита подтверждения, в противном случае между последним \_Tlow/2* и началом STOP последовательности возникает задержка, связанная с уходом на обработчик прерываний, чтением и записью регистров);
- на основании статусного бита STOP регистра I2C_ST0 установить момент завершения подачи STOP последовательности, выключить модуль или продолжить работу.

При потере арбитража во время отправки данных в случае, если адрес записан в первом байте FIFO_TX, пользователь имеет возможность предпринять вторую попытку после освобождения шины без повторного заполнения буфера, сбросив указатель чтения битом RST_TX_RDP регистра I2C_CTRL.

### Процедура приема данных ведущим

- в регистрах I2C_MSK0, I2C_MSK1, I2C_MSK2 разрешить необходимые прерывания;
- в регистре I2C_CFG:
  - установить биты FILT_DEPTH, определяющие глубину фильтрации;
  - определить режим работы FIFO_RX битом EN_OV.
- в регистре I2C_PRSC0 определить длительность высокого и низкого уровня SCL, установив младшие 8 бит PRSC;
- в регистре I2C_PRSC1:
  - определить режим работы битом F/S, если выбран Fast-mode, то задать коэффициент заполнения битом DUTY;
  - определить длительность высокого и низкого уровня SCL, установив старшие 4 бита PRSC.
- в регистре I2C_PRSC3 установить максимальную длительность петли обратной связи линии SCL битами TRISE;
- записать адрес c «1» в младшем бите в регистр I2C_TXFIFO;
- если необходимо принять более одного байта, то необходимо установить количество слов,   
  при котором формируется соответствующий статус в регистре I2C_RXTHRESHOLD   
  (для завершения приема необходимо отправить NACK во время передачи последнего байта, поэтому установленное значение должно быть как минимум на одно меньше, чем принимаемых байт);
- в регистре I2C_CTRL:
  - определить тип адресации битом ADDR_MOD;
  - если необходимо принять более одного байта установить бит ACK;
  - установить бит START;
  - включить модуль битом EN.
- в регистре I2C*CTRL по статусному биту RX_THRESHOLD_PASS регистра I2C_ST1 или FIFO_RX_NOT_EMPTY, или TX_END_EMPTY_FIFO регистра I2C_ST2 (в зависимости   
  от количества принимаемых байт; если бит STOP устанавливается по FIFO_RX_NOT_EMPTY,   
  то между последним \_Tlow*/2\_ и началом STOP последовательности возникает задержка, связанная с уходом на обработчик прерываний, чтением и записью регистров):
  - если принимается более одного байта записать «0» в бит ACK;
  - установить бит STOP.
- на основании статусного бита STOP регистра I2C_ST0 установить момент завершения подачи STOP последовательности, cчитать полученные данные из регистра I2C_RXFIFO, выключить модуль или продолжить работу.

Пользователь имеет возможность считывать буфер принятых данных и изменять регистр I2C_RXTHRESHOLD во время передачи данных ведомым, что позволяет принимать более 8 байт.

### Процедура передачи данных ведомым

- в регистрах I2C_MSK0, I2C_MSK1, I2C_MSK2 разрешить необходимые прерывания;
- в регистре I2C_CFG:
  - установить биты FILT_DEPTH, определяющие глубину фильтрации;
  - определить режим работы FIFO_RX битом EN_OV.
- задать адрес устройства в регистрах I2C_ADDR1 и I2C_ADDR0;
- в регистре I2C_PRSC2 определить длительность удержания уровня SDA после заднего фронта SCL;
- записать отправляемые данные в регистр I2C_TXFIFO;
- в регистре I2C_CTRL:
  - определить тип адресации битом ADDR_MOD;
  - установить бит ACK;
  - включить модуль битом EN.
- дописывать данные в регистр I2C_TXFIFO по мере опустошения выходного буфера, отслеживая его состояние с помощью бит BTF, FIFO_EMPTY_TX или TX_END_EMPTY_FIFO статусных регистров, а также регистра I2C_TXWORDS.

Если на момент чтения нового слова из выходного буфера он пуст, то будут отправлены нули. Мастер должен отправить NACK после приема последнего байта данных, иначе ведомый предпримет попытку продолжить передачу.

### Процедура приема данных ведомым

- в регистрах I2C_MSK0, I2C_MSK1, I2C_MSK2 разрешить необходимые прерывания;
- в регистре I2C_CFG:
  - установить биты FILT_DEPTH, определяющие глубину фильтрации;
  - определить режим работы FIFO_RX битом EN_OV.
- задать адрес устройства в регистрах I2C_ADDR1 и I2C_ADDR0;
- в регистре I2C_PRSC2 определить длительность удержания уровня SDA после заднего фронта SCL;
- в регистре I2C_RXTHRESHOLD установить количество слов, при котором формируется соответствующий статус;
- в регистре I2C_CTRL:
  - определить тип адресации битом ADDR_MOD;
  - установить бит ACK;
  - включить модуль битом EN.
- считывать данные и управлять битом ACK регистра I2C_CTRL по мере формирования соответствующих статусов.

## Статусы и прерывания

В отличии от остальных модулей в I2C:

- прерывание по биту-флагу не формируется, если бит уже находится в «1», и в этот момент разрешается прерывание;
- прерывание по биту-событию не формируется от последующих событий после перехода бита   
  в «1», пока он не будет сброшен чтением обратно в «0».

Остальные принципы работы, описанные в разделе «Типы статусов и прерывания», остаются неизменными.

## Регистры I2C

| **№** | **Аббревиатура** | **Доступ** | **Описание**                                                                                                           |
| ----- | ---------------- | ---------- | ---------------------------------------------------------------------------------------------------------------------- |
| 2A00h | I2C_CFG          | RW         | Регистр конфигурации                                                                                                   |
| 2A04h | I2C_CTRL         | RW         | Регистр управления                                                                                                     |
| 2A08h | I2C_ST0          | R          | Регистр статуса 0                                                                                                      |
| 2A09h | I2C_ST1          | R          | Регистр статуса 1                                                                                                      |
| 2A0Ah | I2C_ST2          | R          | Регистр статуса 2                                                                                                      |
| 2A0Ch | I2C_ADDR0        | RW         | Регистр адреса приемника 0                                                                                             |
| 2A0Dh | I2C_ADDR1        | RW         | Регистр адреса приемника 1                                                                                             |
| 2A10h | I2C_PRSC0        | RW         | Предделитель 0                                                                                                         |
| 2A11h | I2C_PRSC1        | RW         | Предделитель 1                                                                                                         |
| 2A12h | I2C_PRSC2        | RW         | Предделитель 2                                                                                                         |
| 2A13h | I2C_PRSC3        | RW         | Предделитель 3                                                                                                         |
| 2A14h | I2C_MSK0         | RW         | Регистр маски прерываний 0                                                                                             |
| 2A15h | I2C_MSK1         | RW         | Регистр маски прерываний 1                                                                                             |
| 2A16h | I2C_MSK2         | RW         | Регистр маски прерываний 2                                                                                             |
| 2A18h | I2C_TXFIFO       | RW         | Буфер данных на передачу                                                                                               |
| 2A1Ch | I2C_RXFIFO       | R          | Буфер принятых данных                                                                                                  |
| 2A20h | I2C_TXWORDS      | R          | Количество непрочитанных слов в буфере передачи                                                                        |
| 2A24h | I2C_RXTHRESHOLD  | RW         | Указывает количество непрочитанных слов в буфере приема, при котором формируется соответствующий признак в регистре ST |

### **I2C_CFG**

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={2}>Резерв</td>
  <td colSpan={5}>FILT_DEPTH</td>
  <td>EN_OV</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**FILT_DEPTH** – настройка глубины фильтров для входных сигналов SDA, SCL.

Выбирается следующим образом:

$$
FILT\_DEPTH > \frac {T_{noise}}{ {T_{clk}}}
$$

где $$T_{noise}$$ – максимальная длительность помехи, которую необходимо отфильтровать, $$T_{clk}$$ – период частоты тактирования системы.

Соответственно при максимальном значении битов FILT_DEPTH может быть отфильтрована помеха длительностью менее T<sub>clk</sub>. При значении «0» фильтр выключен.

**EN_OV** – при переполнении буфера FIFO приемника разрешает или запрещает перезаписывать данные:

- 1 – перезапись данных разрешена;
- 0 – перезапись данных запрещена.

При приеме в режиме «ведущий», когда переполнение разрешено, контроллер может запрашивать от ведомого новые слова и записывать их поверх старых. При возникновении переполнения поднимается признак FIFO_RX_OV. Если переполнение запрещено ведущий остановит прием после появления признака FIFO_RX_FULL.

При приеме в режиме «ведомый», когда переполнение разрешено, можно записывать новые слова поверх старых. При возникновении переполнения установится признак FIFO_RX_OV. Если переполнение запрещено, ведомый не будет записывать новые слова поверх старых, однако при приеме нового слова и наличии признака FIFO_RX_FULL установится признак FIFO_RX_OV.

### I2C_CTRL

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td>RST_RX_PNTRS</td>
  <td>RST_TX_RDP</td>
  <td>RST_TX_PNTRS</td>
  <td>ADDR_MOD</td>
  <td>ACK</td>
  <td>STOP</td>
  <td>START</td>
  <td>EN</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**RST_RX_PNTRS** – запись единицы приводит к сбросу указателей FIFO_RX.

**RST_TX_RDP (Reset Transmitter Read Pointer)** – запись единицы приводит к сбросу указателя чтения FIFO_TX.

**RST_TX_PNTRS** – запись единицы приводит к сбросу указателей FIFO_TX.

**ADDR_MOD** – тип адресации:

- 1 – 10-ти битная адресация;
- 0 – 7-ми битная адресация.

**ACK** – разрешение подтверждение после приема байта (адреса или данных):

- 1 – отправлять подтверждение;
- 0 – не отправлять подтверждение.

При переводе бита в «0» модуль запишет последний байт в буфер приема и подаст на линию NACK.

**STOP** – сформировать STOP последовательность:

- 1 – в режиме «ведущий» формируется STOP;
- 0 – STOP не формируется.

Бит переводится в «0» устройством после STOP.

**START** – сформировать START последовательность.:

- 1 – в режиме «ведущий» формируется START;
- 0 – START не формируется.

Бит переводится в «0» устройством после START.

**EN** – разрешение работы модуля:

- 1 – модуль включен;
- 0 – модуль выключен.

### I2C_ST0

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td>FIFO_RX_OV</td>
  <td>FIFO_RX_FULL</td>
  <td>ARB_LOST</td>
  <td>BUS_ERROR</td>
  <td>ACK_FAILURE</td>
  <td>BTF</td>
  <td>STOP</td>
  <td>START</td>
</tr>
<tr>
  <th>Тип статуса</th>
  <td colSpan={2}>FLAG</td>
  <td>EVENT</td>
  <td>EVENT</td>
  <td>EVENT</td>
  <td>EVENT</td>
  <td>EVENT</td>
  <td>EVENT</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**FIFO_RX_OV** – FIFO_RX переполнен.

**FIFO_RX_FULL** – FIFO_RX полностью заполнен. При наличии FIFO_RX_OV обнуляется, контролироваться не должен.

**ARB_LOST** – признак потери арбитража (только для режима «ведущий»). При потере арбитража в процессе передачи слова данных ведущий продолжает формировать импульсы SCL для всех 8 бит данных, затем освобождает линию SCL, и после этого формирует статус ARB_LOST.

**BUS_ERROR** – признак несвоевременного события START или STOP. Признак появляется, если зафиксирован перепад линии SDA на фоне единичного уровня SCL во время передачи байта данных или бита подтверждения.

**ACK_FAILURE** – не было подтверждения после передачи байта данных/адреса.

**BTF (Byte Transfer Completed)** – обмен байтом завершен:

- 1 – обмен байтом завершился успешно;
- 0 – обмена байтом не было/завершился не успешно.

Переводится в единицу, если:

- при приеме, когда принят новый байт и отправлен ACK/NACK;
- при передаче, если байт был передан и получен ACK.

Примечание: если при передаче байта принят NACK, BTF не переводится в единицу.

**STOP** – в режиме «ведущий» сформирован STOP, в режиме «ведомый» обнаружен STOP.

**START** – в режиме «ведущий» сформирован START, в режиме «ведомый» обнаружен START.

### I2C_ST1

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

  <tr>
    <th >Назначение</th>
    <td >RX<br/>THRESHOLD<br/>PASS</td>
    <td >MODE</td>
    <td >BUS_CLEAR</td>
    <td >SLV_RX</td>
    <td >SLV_TX</td>
    <td >FIFO<br/>EMPTY<br/>TX</td>
    <td >FIFO<br/>FULL<br/>TX</td>
    <td >FIFO<br/>RX<br/>NOT_EMPTY</td>
  </tr>
  <tr>
    <th >Тип статуса</th>
    <td colSpan={8} >FLAG</td>
  </tr>
    <tr>
    <th >Начальное значение</th>
    <td >1</td>
    <td >0</td>
    <td >1</td>
    <td >0</td>
    <td >0</td>
    <td >1</td>
    <td >0</td>
    <td >0</td>
  </tr>
</tbody>
</table>

**RX_THRESHOLD_PASS** – количество непрочитанных слов в буфере приема больше либо равно значению регистра I2C_RX_THRESHOLD.

**MODE** – режим:

- 1 – блок находится в режиме «ведущий»;
- 0 – блок находится в режиме «ведомый».

**BUS_CLEAR** – признак того, что на линии не идет обмен. Линия будет считаться занятой, если зафиксирован низкий уровень на линиях SDA или SCL, и свободной – если произошло событие STOP.

**SLV_RX** – признак, что в режиме «ведомый» устройство адресовано на запись.

**SLV_TX** – признак, что в режиме «ведомый» устройство адресовано на чтение.

**FIFO_EMPTY_TX** – FIFO*TX пуст. Возникает перед передачей последнего слова данных в момент чтения из буфера (за такт системной частоты до выдачи первого бита на линии SDA в момент времени \_Tlow*/2).

**FIFO_FULL_TX** – FIFO_TX полностью заполнен.

**FIFO_RX_NOT_EMPTY** – FIFO_RX не пуст. При наличии FIFO_RX_OV обнуляется, контролироваться не должен.

### I2C_ST2

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={7}>Резерв</td>
  <td>TX_END_EMPTY_FIFO</td>
</tr>
<tr>
  <th>Тип статуса</th>
  <td colSpan={7}></td>
  <td>EVENT</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**TX_END_EMPTY_FIFO** – признак того, что в момент завершения передачи слова буфер передачи был пуст. Возникает в момент завершения приема ACK либо NACK после передачи слова (за такт системной частоты до _Tlow_/2).

### I2C_ADDR0

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={8}>ADDR</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**ADDR** – адрес в режиме «ведомый», младшая часть.

### I2C_ADDR1

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={7}>Резерв</td>
  <td>ADDR</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**ADDR** – адрес в режиме «ведомый», старшая часть.

### I2C_PRSC0

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={8}>PRSC</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**PRSC** – предделитель, младшая часть.

### I2C_PRSC1

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td>F/S</td>
  <td>DUTY</td>
  <td colSpan={2}>Резерв</td>
  <td colSpan={4}>PRSC</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**F/S** – режим:

- 1 – Fast-mode;
- 0 – Standard-mode.

**DUTY** – коэффициент заполнения для Fast-mode:

$$
1 - \frac {T_{high}}{T_{low}} = \frac {9}{16}
$$

$$
1 - \frac {T_{high}}{T_{low}} = \frac {1}{2}
$$

**PRSC** – предделитель, определяет длительность высокого (_Thigh_) и низкого (_Tlow_) уровня SCL в режиме «ведущий», старшая часть.

**При Fast-mode и DUTY = 1:**

$$
T_{high} = 9 \cdot PRSC \cdot T_{clk}
$$

$$
T_{low} = 16 \cdot PRSC \cdot T_{clk}
$$

**При Fast-mode и DUTY = 0:**

$$
T_{high} = PRSC \cdot T_{clk}
$$

$$
T_{low} = 2 \cdot PRSC \cdot T_{clk}
$$

**При Standard-mode:**

$$
T_{high} = 2 \cdot PRSC \cdot T_{clk}
$$

$$
T_{low} = 2 \cdot PRSC \cdot T_{clk}
$$

При установке битов PRSC необходимо, чтобы общее время, затраченное на обратную связь при спаде SCL, не превышало T<sub>low</sub>/2 . Для этого достаточно выполнения следующего неравенства:

$$
\frac {T_{low}}{2 \cdot T_{clk}} > \lceil \frac{T_{fall}}{T_{clk}}\rceil + FILT\_DEPTH +2
$$

где T<sub>fall</sub> – максимальная длительность заднего фронта SCL на входе устройства. Из этого следует, что при Standard-mode или Fast-mode с DUTY в «0» и T<sub>fall</sub> намного меньше T<sub>clk</sub> минимальное значение битов PRSC равно 3 при выключенном фильтре (биты FILT_DEPTH в «0»), однако рекомендуется округлять отношение длительности заднего фронта и периода синхросигнала в большую сторону.

### I2C_PRSC2

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={8}>SLV_HLD</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**SLV_HLD** – длительность удержания уровня SDA, младшая часть.

### I2C_PRSC3

<table className="table">
<tbody>

<tr>
  <th>Бит</th>
  <th>7</th>
  <th>6</th>
  <th>5</th>
  <th>4</th>
  <th>3</th>
  <th>2</th>
  <th>1</th>
  <th>0</th>
</tr>

<tr>
  <th>Назначение</th>
  <td>Резерв</td>
  <td colSpan={5}>TRISE</td>
  <td colSpan={2}>SLV_HLD</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**TRISE** – максимальная длительность петли обратной связи линии SCL в режиме «ведущий». Используется с целью установить корректную скважность на линии SCL, которая не будет зависеть от длительности переднего фронта SCL на входе устройства и глубины фильтрации. Значение должно быть установлено исходя из максимального времени нарастания переднего фронта SCL, выраженного в периодах частоты тактирования системы:

$$
 TRISE = \lceil \frac{T_{rise}}{T_{clk}}\rceil + FILT\_DEPTH + 3
$$

где T<sub>rise</sub> – максимальная длительность переднего фронта SCL на входе устройства.

Также следует учитывать:

$$
TRISE \le \frac {T_{high}}{T_{clk}}
$$

**SLV_HLD** – длительность удержания уровня SDA, старшая часть. В режиме «ведомый» через поле SLV_HLD определяется длительность удержания уровня SDA от заднего фронта SCL до выдачи бита ведомым I2C:

$$
T_{hold} = T_{fall} + (FILT\_DEPTH + SLV\_HLD +6) \cdot T_{clk}
$$

### I2C_MSK0

Возможно формирование прерывания по любому биту статусного регистра I2C_ST0. Расположение битов в I2C_ST0 и I2C_MSK0 аналогично.

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td>FIFO_RX_OV</td>
  <td>FIFO_RX_FULL</td>
  <td>ARB_LOST</td>
  <td>BUS_ERROR</td>
  <td>ACK_FAILURE</td>
  <td>BTF</td>
  <td>STOP</td>
  <td>START</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

Для каждого из битов справедливо:

- 1 – данное прерывание формируется;
- 0 – данное прерывание не формируется.

### I2C_MSK1

Возможно формирование прерывания по любому биту статусного регистра I2C_ST1. Расположение битов в I2C_ST1 и I2C_MSK1 аналогично.

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td>RX_THRESHOLD_PASS</td>
  <td>MODE</td>
  <td>BUS_CLEAR</td>
  <td>SLV_RX</td>
  <td>SLV_TX</td>
  <td>FIFO_EMPTY_TX</td>
  <td>FIFO_FULL_TX</td>
  <td>FIFO_RX_NOT_EMPTY</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

Для каждого из битов справедливо:

- 1 – данное прерывание формируется;
- 0 – данное прерывание не формируется.

### I2C_MSK2

Расположение статусного бита аналогично I2C_ST2.

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={7}>Резерв</td>
  <td>TX_END_EMPTY_FIFO</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**TX_END_EMPTY_FIFO** - разрешить прерывание по статусу TX_END_EMPTY_FIFO:

- 1 – данное прерывание формируется;
- 0 – данное прерывание не формируется.

### I2C_TXFIFO

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={8}>TX_FIFO</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**TX_FIFO** – буфер передаваемых данных. При передаче адреса в режиме «ведущий» пользователь должен самостоятельно задать R/W битом 0.

### I2C_RXFIFO

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={8}>RX_FIFO</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**RX_FIFO** – буфер принятых данных.

### I2C_TXWORDS

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={4}>Резерв</td>
  <td colSpan={4}>TX_WORDS</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**TX_WORDS** – количество непрочитанных слов в буфере передачи (от 0 до 8).

### I2C_RXTHRESHOLD

<table className="table">
<tbody>
 
  <tr>
    <th >Бит</th>
    <th >7</th>
    <th >6</th>
    <th >5</th>
    <th >4</th>
    <th >3</th>
    <th >2</th>
    <th >1</th>
    <th >0</th>
  </tr>

<tr>
  <th>Назначение</th>
  <td colSpan={4}>Резерв</td>
  <td colSpan={4}>RX_THRES</td>
</tr>

  <tr>
    <th >Начальное значение</th>
    <td colSpan={8} >0</td>
  </tr>
</tbody>
</table>

**RX_THRES** – количество непрочитанных слов в буфере приема (от 0 до 8), при котором формируется соответствующий признак в регистре статуса.
